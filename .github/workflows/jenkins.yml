name: Build and Deploy Jenkins
on:
  push:
    branches: [ master ]
  workflow_dispatch:

env:
  REGISTRY: docker.io
  IMAGE_NAME: owolabialiu/my-jenkins-custom-git
  KUBERNETES_NAMESPACE: jenkins

jobs:
  build-and-deploy:
    name: Build Plugin, Docker Image, and Deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Create Maven extensions to ensure HPI plugin is loaded
      - name: Create Maven extensions file
        run: |
          mkdir -p .mvn
          cat > .mvn/extensions.xml << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <extensions>
            <extension>
              <groupId>org.jenkins-ci.tools</groupId>
              <artifactId>maven-hpi-plugin</artifactId>
              <version>3.65</version>
            </extension>
          </extensions>
          EOF

      # Alternative: Use install goal to force proper packaging recognition
      - name: Build plugin using install
        run: |
          echo "Building Jenkins plugin with install goal..."
          mvn --batch-mode --errors --fail-at-end --show-version \
            --settings .github/workflows/settings.xml \
            clean install -DskipTests
        
      - name: Debug - List generated files
        run: |
          echo "=== Searching for plugin files ==="
          find . -name "*.hpi" -o -name "*.jpi" | head -10
          echo "=== Target directory contents ==="
          ls -la target/ || echo "No target directory found"
          echo "=== Maven work directory ==="
          find . -type d -name "work" | head -5
          echo "=== Plugin archives ==="
          find . -maxdepth 3 -type f -name "*.*pi" 2>/dev/null | head -10

      - name: Prepare plugin for Docker
        run: |
          mkdir -p docker-context
          
          # Function to copy plugin file
          copy_plugin_file() {
            local source_file="$1"
            local dest_file="docker-context/my-custom-git-plugin.jpi"
            
            if [ -f "$source_file" ]; then
              cp "$source_file" "$dest_file"
              echo "Copied plugin: $source_file -> $dest_file"
              ls -la "$dest_file"
              return 0
            fi
            return 1
          }
          
          # Try to find and copy plugin file in order of preference
          plugin_found=false
          
          # Check target directory first for .hpi files
          for file in target/*.hpi; do
            if [ -f "$file" ] && copy_plugin_file "$file"; then
              plugin_found=true
              break
            fi
          done
          
          # Check target directory for .jpi files
          if [ "$plugin_found" = false ]; then
            for file in target/*.jpi; do
              if [ -f "$file" ] && copy_plugin_file "$file"; then
                plugin_found=true
                break
              fi
            done
          fi
          
          # Look recursively for any plugin files
          if [ "$plugin_found" = false ]; then
            while IFS= read -r -d '' file; do
              if copy_plugin_file "$file"; then
                plugin_found=true
                break
              fi
            done < <(find . -name "*.hpi" -o -name "*.jpi" -type f -print0 2>/dev/null)
          fi
          
          # List what we have in docker-context
          echo "=== Docker context contents ==="
          ls -la docker-context/
          
          # Verify we have the plugin file
          if [ ! -f docker-context/my-custom-git-plugin.jpi ]; then
            echo "ERROR: Plugin file not found!"
            echo "=== Debug: All potential plugin files ==="
            find . -name "*.hpi" -o -name "*.jpi" -o -name "*.jar" | grep -i plugin || echo "No plugin files found"
            echo "=== Debug: Target directory tree ==="
            find target -type f 2>/dev/null | head -20 || echo "No target directory"
            echo "=== Debug: Full directory listing ==="
            find . -maxdepth 2 -type f | head -30
            exit 1
          fi
          
          echo "Plugin file prepared successfully!"

      - name: Validate Docker context
        run: |
          echo "=== Final Docker context validation ==="
          ls -la docker-context/
          file docker-context/my-custom-git-plugin.jpi || echo "Could not determine file type"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.12.0'

      - name: Configure kubectl
        uses: azure/k8s-set-context@v4
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.KUBE_CONFIG }}

      - name: Deploy with Helm
        run: |
          echo "Deploying Jenkins with custom plugin..."
          helm upgrade --install my-jenkins ./helm \
            --namespace ${{ env.KUBERNETES_NAMESPACE }} \
            --create-namespace \
            --set controller.image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set controller.image.tag=${{ github.sha }} \
            --set controller.image.pullPolicy=Always \
            --set controller.installPlugins=false \
            --wait --timeout=10m

      - name: Verify deployment
        run: |
          echo "=== Deployment Status ==="
          kubectl get pods -n ${{ env.KUBERNETES_NAMESPACE }}
          kubectl get svc -n ${{ env.KUBERNETES_NAMESPACE }}
          
          echo "=== Checking pod logs ==="
          kubectl logs -l app.kubernetes.io/name=jenkins \
            -n ${{ env.KUBERNETES_NAMESPACE }} \
            --tail=50 || echo "Could not fetch logs"

      - name: Output deployment info
        run: |
          echo "=== Deployment Information ==="
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "Namespace: ${{ env.KUBERNETES_NAMESPACE }}"
          echo "Jenkins URL: Check your LoadBalancer/Ingress configuration"